---
title: "Tugas Praktikum 3 MPDW"
author: "David Fauzan Akmal"
date: "2024-09-09"
output: html_document
---

## *Packages*

```{r, echo=FALSE}
library(dLagM)
library(dynlm)
library(MLmetrics)
library(lmtest)
library(car)
library(readxl)
```

## Impor Data

Data yang digunakan adalah data jumlah pelanggan dan pendapatan aplikasi streaming Netflix yang saya peroleh dari businessofapps.com. Jumlah pelanggan sebagai variabel independen dan jumlah pendapatan sebagai variabel dependen.
```{r}
dtNetflix <- read_excel("C://Users/USER/Downloads/Data Pelanggan dan Pendapatan Netflix.xlsx")
  Yt = dtNetflix$'Pendapatan (Juta Dolar)'
  Xt = dtNetflix$'Pelanggan (Juta)'
  
data = data.frame(Yt, Xt)
data
```


## Pembagian Data

```{r}
#SPLIT DATA
train<-data[1:38,]
test<-data[39:51,]
```

```{r}
#data time series
train.ts<-ts(train)
test.ts<-ts(test)
data.ts<-ts(data)
```

## Model Koyck

Model Koyck didasarkan pada asumsi bahwa semakin jauh jarak lag peubah independen dari periode sekarang maka semakin kecil pengaruh peubah lag terhadap peubah dependen.

Koyck mengusulkan suatu metode untuk menduga model dinamis distributed lag dengan mengasumsikan bahwa semua koefisien $\beta$ mempunyai tanda sama.

Model kyock merupakan jenis paling umum dari model infinite distributed lag dan juga dikenal sebagai geometric lag

$$
y_t=a(1-\lambda)+\beta_0X_t+\beta_1Z_t+\lambda Y_{t-1}+V_t
$$

dengan $$V_t=u_t-\lambda u_{t-1}$$

### Pemodelan

Pemodelan model Koyck dengan `R` dapat menggunakan `dLagM::koyckDlm()` . Fungsi umum dari `koyckDlm` adalah sebagai berikut.

Fungsi `koyckDlm()` akan menerapkan model lag terdistribusi dengan transformasi Koyck satu prediktor. Nilai `x` dan `y` tidak perlu sebagai objek *time series* (`ts`). `intercept` dapat dibuat `TRUE` untuk memasukkan intersep ke dalam model.

```{r}
#MODEL KOYCK
model.koyck <- koyckDlm(x = train$Xt, y = train$Yt)
summary(model.koyck)
AIC(model.koyck)
BIC(model.koyck)
```

Dari hasil tersebut, didapat bahwa peubah $x_t$ dan $y_{t-1}$ memiliki nilai $P-Value<0.05$. Hal ini menunjukkan bahwa peubah $x_t$ dan $y_{t-1}$ berpengaruh signifikan terhadap $y$. Adapun model keseluruhannya adalah sebagai berikut

$$
\hat{Y_t}=-31.20660+0.88294X_t+5.40383_{t-1}
$$

### Peramalan dan Akurasi

Berikut adalah hasil peramalan y untuk 13 periode kedepan menggunakan model koyck

```{r}
fore.koyck <- forecast(model = model.koyck, x=test$Xt, h=13)
fore.koyck
mape.koyck <- MAPE(fore.koyck$forecasts, test$Yt)
#akurasi data training
GoF(model.koyck)
```
## Regression with Distributed Lag

Pemodelan model Regression with Distributed Lag dengan `R` dapat menggunakan `dLagM::dlm()` . Fungsi umum dari `dlm` adalah sebagai berikut.

```{r, eval=FALSE, error=FALSE}
dlm(formula , data , x , y , q , remove )
```

Fungsi `dlm()` akan menerapkan model lag terdistribusi dengan satu atau lebih prediktor. Nilai `x` dan `y` tidak perlu sebagai objek *time series* (`ts`). $q$ adalah integer yang mewakili panjang *lag* yang terbatas.

### Pemodelan (Lag=2)

```{r}
model.dlm <- dlm(x = train$Xt,y = train$Yt , q = 2)
summary(model.dlm)
AIC(model.dlm)
BIC(model.dlm)
```

Dari hasil diatas, didapat bahwa $P-value$ dari intercept $<0.05$. Hal ini menunjukkan bahwa intercept berpengaruh signifikan terhadap $y$. Adapun model keseluruhan yang terbentuk adalah sebagai berikut

$$
\hat{Y_t}=-218.66+11.57X_t+6.88X_{t-1}+16.19X_{t-2}
$$

### Peramalan dan Akurasi

Berikut merupakan hasil peramalan $y$ untuk 13 periode kedepan

```{r}
fore.dlm <- forecast(model = model.dlm, x=test$Xt, h=13)
fore.dlm
mape.dlm <- MAPE(fore.dlm$forecasts, test$Yt)
#akurasi data training
GoF(model.dlm)
```

### *Lag* Optimum


```{r}
#penentuan lag optimum 
finiteDLMauto(formula = Yt ~ Xt,
              data = data.frame(train), q.min = 1, q.max = 20,
              model.type = "dlm", error.type = "AIC", trace = FALSE)
```

Berdasarkan output tersebut, lag optimum didapatkan ketika lag=17 karena di lag 18 nilainya inf. Selanjutnya dilakukan pemodelan untuk lag=17

```{r}
#model dlm dengan lag optimum
model.dlm2 <- dlm(x = train$Xt,y = train$Yt , q = 17)
summary(model.dlm2)
AIC(model.dlm2)
BIC(model.dlm2)
```

Dari hasil tersebut, tidak ada peubah yang berpengaruh signifikan pada taraf nyata 5%. Adapun keseluruhan model yang terbentuk adalah

$$
\hat{Y_t}=1906.173+-23.787X_t+...+17.714X_{t-17}
$$

Adapun hasil peramalan 13 periode kedepan menggunakan model tersebut adalah sebagai berikut

```{r}
#peramalan dan akurasi
fore.dlm2 <- forecast(model = model.dlm2, x=test$Xt, h=13)
mape.dlm2<- MAPE(fore.dlm2$forecasts, test$Yt)
#akurasi data training
GoF(model.dlm2)
```

Model tersebut merupakan model yang sangat baik dengan nilai MAPE yang kurang dari 10%.

## Model Autoregressive

Peubah dependen dipengaruhi oleh peubah independen pada waktu sekarang, serta dipengaruhi juga oleh peubah dependen itu sendiri pada satu waktu yang lalu maka model tersebut disebut *autoregressive* (Gujarati 2004).

### Pemodelan
Pemodelan Autoregressive dilakukan menggunakan fungsi `dLagM::ardlDlm()` . Fungsi tersebut akan menerapkan *autoregressive* berordo $(p,q)$ dengan satu prediktor. Fungsi umum dari `ardlDlm()` adalah sebagai berikut.

```{r, eval=FALSE}
ardlDlm(formula = NULL , data = NULL , x = NULL , y = NULL , p = 1 , q = 1 , 
         remove = NULL )
```

Dengan $p$ adalah integer yang mewakili panjang *lag* yang terbatas dan $q$ adalah integer yang merepresentasikan ordo dari proses *autoregressive*.


```{r}
model.ardl <- ardlDlm(formula = Yt ~ Xt, data = train,p = 1 , q = 1)
summary(model.ardl)
```

Hasil di atas menunjukkan bahwa selain peubah $y_{t-1}$, hasil uji t menunjukkan nilai-p pada peubah $\ge0.05$ Hal ini menunjukkan bahwa peubah $y_{t-1}$ berpengaruh signifikan terhadap $y_t$, sementara intercept, $x_t$, dan $x_{t-1}$ tidak berpengaruh signifikan terhadap $y_t$. Model keseluruhannya adalah sebagai berikut:

$$
\hat{Y}=-29.40702+4.15693X_t+1.28572X_{t-1}+0.88332Y_{t-1}
$$


### Peramalan dan Akurasi

```{r}
fore.ardl <- forecast(model = model.ardl, x=test$Xt, h=13)
fore.ardl
```

Data di atas merupakan hasil peramalan untuk 13 periode ke depan menggunakan Model Autoregressive dengan $p=1$ dan $q=1$.

```{r}
mape.ardl <- MAPE(fore.ardl$forecasts, test$Yt)
mape.ardl
#akurasi data training
GoF(model.ardl)
```

Berdasarkan akurasi di atas, terlihat bahwa nilai MAPE keduanya tidak jauh berbeda. Artinya, model regresi dengan distribusi lag ini tidak `overfitted` atau `underfitted`

### *Lag* Optimum

```{r}
acf(train)
```


Dari plot tersebut, dapat diketahui bahwa lag peubah y optimum di lag ke-9 (p), sementara lag peubah x akan dicoba trial and error di bawah.


```{r}
model.ardl.opt <- ardlBoundOrders(data = data.frame(data), ic = "AIC", 
                                  formula = Yt ~ Xt )
```

### Mencari nilai q (Lag Peubah X)
```{r}
stattable = model.ardl.opt$Stat.table
stattable
```

Dari tabel di atas, dapat dilihat di baris p = 9 bahwa nilai q di bawah 14 dengan AIC paling rendah adalah q = 13. Setelah lag 15, hanya bisa dipakai 23 data, sehingga jumlah p+q tidak boleh melebihi 23. Oleh karena itu, di sini dicari lag dari peubah x (q) yang di bawah 14.


## Cek Akurasi dengan p = 9 dan q = 13

```{r}
modelardl.baru <- ardlDlm(formula = Yt ~ Xt, data = train,p = 9 , q = 13)
GoF(modelardl.baru)
```

Selanjutnya dapat dilakukan pemodelan dengan nilai $p$ dan $q$ optimum seperti inisialisasi di langkah sebelumnya.

## Pemodelan DLM & ARDL dengan Library `dynlm`

Pemodelan regresi dengan peubah *lag* tidak hanya dapat dilakukan dengan fungsi pada *packages* `dLagM` , tetapi terdapat *packages* `dynlm` yang dapat digunakan. Fungsi `dynlm` secara umum adalah sebagai berikut.

```{r, eval=FALSE}
dynlm(formula, data, subset, weights, na.action, method = "qr",
  model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,
  contrasts = NULL, offset, start = NULL, end = NULL, ...)
```

Untuk menentukan `formula` model yang akan digunakan, tersedia fungsi tambahan yang memungkinkan spesifikasi dinamika (melalui `d()` dan `L()`) atau pola linier/siklus dengan mudah (melalui `trend()`, `season()`, dan `harmon()`). Semua fungsi formula baru mengharuskan argumennya berupa objek deret waktu (yaitu, `"ts"` atau `"zoo"`).

```{r}
#sama dengan model dlm q=13
cons_lm1 <- dynlm(Yt ~ Xt + L(Xt, 1) + L(Xt, 2) + L(Xt, 3) + L(Xt, 4) +
                        L(Xt, 5)+ L(Xt, 6)+ L(Xt, 7)+ L(Xt, 8)+ L(Xt, 9) + 
                        L(Xt, 10) + L(Xt, 11) + L(Xt, 12) + L(Xt, 13), data=train.ts)

#sama dengan model ardl p=9 q=0
cons_lm2 <- dynlm(Yt ~ Xt + L(Yt, 1) + L(Yt, 2) + L(Yt, 3) + L(Yt, 4) +
                        L(Yt, 5) + L(Yt, 6) + L(Yt, 7) + L(Yt, 8) + L(Yt, 9), data = train.ts)

#sama dengan ardl p=9 q=13
cons_lm3 <- dynlm(Yt ~ Xt + L(Xt, 1) + L(Xt, 2) + L(Xt, 3) + L(Xt, 4) + 
                        L(Xt, 5) + L(Xt, 6) + L(Xt, 7) + L(Xt, 8) + L(Xt, 9) + L(Xt, 10) + L(Xt, 11) + L(Xt, 12) + L(Yt, 13)+ L(Yt, 1) + L(Yt, 2) + L(Yt, 3) + L(Yt, 4) +
                        L(Yt, 5) + L(Yt, 6) + L(Yt, 7) + L(Yt, 8) + L(Yt, 9), data = train.ts)

#sama dengan dlm p=10
cons_lm4 <- dynlm(Yt ~ Xt + L(Yt, 1) + L(Yt, 2) + L(Yt, 3) + L(Yt, 4) +
                        L(Yt, 5) + L(Yt, 6) + L(Yt, 7) + L(Yt, 8) + L(Yt, 9) + L (Yt, 10), data=train.ts)
```

### Ringkasan Model

```{r}
summary(cons_lm1)
summary(cons_lm2)
summary(cons_lm3)
summary(cons_lm4)
```

### SSE

```{r}
deviance(cons_lm1)
deviance(cons_lm2)
deviance(cons_lm3)
deviance(cons_lm4)
```

### Uji Diagnostik

```{r}
#uji model
#if(require("lmtest")) encomptest(cons_lm1, cons_lm2)
#Tidak dilakukan karena panjang cons_lm1 dan cons_lm2 berbeda. cons_lm1 lagnya 13 dan cons_lm2 lagnya 9 sehingga jumlah datanya berbeda.
```

#### Autokorelasi

```{r}
#durbin watson
dwtest(cons_lm1)
dwtest(cons_lm2)
dwtest(cons_lm3)
dwtest(cons_lm4)
```

#### Heterogenitas

```{r}
bptest(cons_lm1)
bptest(cons_lm2)
bptest(cons_lm3)
bptest(cons_lm4)
```

#### Kenormalan

```{r}
shapiro.test(residuals(cons_lm1))
shapiro.test(residuals(cons_lm2))
shapiro.test(residuals(cons_lm3))
shapiro.test(residuals(cons_lm4))
```

## Perbandingan Model

```{r}
akurasi <- matrix(c(mape.koyck, mape.dlm, mape.dlm2, mape.ardl))
row.names(akurasi)<- c("Koyck","DLM 1","DLM 2","Autoregressive")
colnames(akurasi) <- c("MAPE")
akurasi
```

Berdasarkan nilai MAPE, model paling optimum didapat pada Model Koyck karena memiliki nilai MAPE yang terkecil.

### Plot

```{r}
par(mfrow=c(1,1))
plot(test$Xt, test$Yt, type="b", col="black")
points(test$Xt, fore.koyck$forecasts,col="red")
lines(test$Xt, fore.koyck$forecasts,col="red")
points(test$Xt, fore.dlm$forecasts,col="blue")
lines(test$Xt, fore.dlm$forecasts,col="blue")
points(test$Xt, fore.dlm2$forecasts,col="orange")
lines(test$Xt, fore.dlm2$forecasts,col="orange")
points(test$Xt, fore.ardl$forecasts,col="green")
lines(test$Xt, fore.ardl$forecasts,col="green")
legend("topleft",c("aktual", "koyck","DLM 1","DLM 2", "autoregressive"), lty=1, col=c("black","red","blue","orange","green"), cex=0.8)
```

Berdasarkan plot tersebut, terlihat bahwa plot yang paling mendekati data aktualnya adalah Model koyck, sehingga dapat disimpulkan model terbaik dalam hal ini adalah model regresi koyck